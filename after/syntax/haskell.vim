function! s:make_highlight_groups(pattern_chars)
    " We need to generate a syntax group for some string. Let's just take
    " progressive pieces from the hash of the whole operator, which should
    " be unique, since there should not be two operators which are the same
    let groups = []
    let op_hash = sha256(join(a:pattern_chars, ''))
    for index in range(0, len(a:pattern_chars)-1)
        call add(groups, op_hash[:(16+index)])
    endfor
    return groups
endfunction

function! s:conceal_pattern(left_pattern, pattern_chars, conceal_chars, right_pattern)
    let groups = s:make_highlight_groups(a:pattern_chars)

    for index in range(0, len(a:pattern_chars)-1)
		let pattern_char = substitute(a:pattern_chars[index], '\', '\\\\', 'g')
        let ccharstr = empty(a:conceal_chars[index])? '' : ' cchar='.a:conceal_chars[index]
        exe "syntax match ".groups[index]." contained '\\V".pattern_char."' conceal ".ccharstr
    endfor

	let pattern = substitute(join(a:pattern_chars, ''), '\', '\\\\', 'g')
    let full_pattern = '\V'.a:left_pattern.pattern.a:right_pattern.'\C'
	" Escape any '\' characters
    exe "syntax match concealedOperator '".full_pattern."' contains=".join(groups, ',')
endfunction

function! s:conceal_operator(pattern_chars, conceal_chars)
    " Taken from the Haskell report (describes syntax for operators)
    "
    " [pattern]         optional
    " {pattern}         zero or more repetitions
    " (pattern)         grouping
    " pat1 | pat2       choice
    " pat<pat'>         difference---elements generated by pat except those generated by pat'
    "
    " special    ->   ( | ) | , | ; | [ | ] | `| { | } 
    " ascSymbol  ->   ! | # | $ | % | & | * | + | . | / | < | = | > | ? | @ | ^ | | | - | ~
    " uniSymbol  ->   any Unicode symbol or punctuation 
    " symbol     ->   ascSymbol | uniSymbol<special | _ | : | " | '>
    " varsym     ->   ( symbol {symbol | :})<reservedop | dashes>
    " consym     ->   (: {symbol | :})<reservedop>
    " reservedop ->   .. | : | :: | = | \ | | | <- | -> | @ | ~ | =>
    let symbol = '!#$%&*+./<=>?@^|\-~:'
    " To understand this pattern, look at :h '\@!'. It is basically saying
    " match a:op but neither preceded nor followed by symbol
	let left_patt = '\(\['.symbol.']\)\@<!'
	let right_patt = '\(\['.symbol.']\)\@!'
    call s:conceal_pattern(left_patt, a:pattern_chars, a:conceal_chars, right_patt)
endfunction 

function! s:conceal_identifier(pattern_chars, conceal_chars)
    let symbol = "[:alnum:]_'"
	let left_patt = '\(\['.symbol.']\)\@<!'
	let right_patt = '\(\['.symbol.']\)\@!'
    call s:conceal_pattern(left_patt, a:pattern_chars, a:conceal_chars, right_patt)
endfunction

if !exists("g:haskell_conceal_definitions")
	finish
endif

if has_key(g:haskell_conceal_definitions, 'operators')
	for op in g:haskell_conceal_definitions['operators']
		call s:conceal_operator(op[0], op[1])
	endfor
endif

if has_key(g:haskell_conceal_definitions, 'identifiers')
	for op in g:haskell_conceal_definitions['identifiers']
		call s:conceal_identifier(op[0], op[1])
	endfor
endif

if has_key(g:haskell_conceal_definitions, 'patterns')
	for op in g:haskell_conceal_definitions['patterns']
		call s:conceal_pattern(op[0], op[1], op[2], op[3])
	endfor
endif
